import NodeJose from "node-jose";
import { validate as isValidUUID } from "uuid";
const { JWS, JWK } = NodeJose;
const legacyPemHeader = "-----BEGIN ECDSA Private Key-----";
const legacyPemFooter = "-----END ECDSA Private Key-----";
const pemHeader = "-----BEGIN EC PRIVATE KEY-----";
const pemFooter = "-----END EC PRIVATE KEY-----";
const AUDIENCES = {
    ops: "corekms_operations_service",
    cws: "waas_consumer_wallet_service"
};
const SECURE_SANDBOX_URLS = {
    DEV: "secure-waas-dev.cbhq.net",
    STAGING: "secure-waas-staging.cbhq.net",
    PROD: "secure-waas.coinbase.com"
};
const BASE_CLOUD_URLS = {
    DEV: "cloud-api-dev.cbhq.net",
    STAGING: "cloud-api-staging.cbhq.net",
    PROD: "api.developer.coinbase.com"
};
const WAAS_ENV_VALUE = process.env.WAAS_ENV?.toUpperCase() ?? "PROD";
const MAX_TTL_SECONDS = 15 * 60;
if (!Object.keys(SECURE_SANDBOX_URLS).includes(WAAS_ENV_VALUE)) {
    throw new Error(`Invalid WAAS_ENV (got: ${WAAS_ENV_VALUE}). Please set WAAS_ENV to: DEV, STAGING, or PROD.`);
}
function urisForEnv(env, useSecureSandbox) {
    let envPrefix;
    if (useSecureSandbox) {
        envPrefix = SECURE_SANDBOX_URLS[env];
    }
    else {
        envPrefix = BASE_CLOUD_URLS[env];
    }
    return {
        cws: [
            `POST ${envPrefix}/waas/consumer/wallets/v1/addresses:generateAddress`,
            `GET ${envPrefix}/waas/consumer/wallets/v1/addresses`
        ],
        ops: [
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/GetCACertificate",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/InitSession2",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/ChangePasscode",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/ValidatePasscode",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/Status",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/HDMPCKeySetMultiCurveGeneratePartner",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/MpcMessageSend",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/MpcMessageReceive",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/FinalizeHDMPCKeySetMultiCurveGenerate",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/HDMPCKeySetMultiCurveGetDerivedPublicKeysPartner",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/FinalizeHDMPCKeySetGetPublicKeys",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/KeySetSignEcdsaPartner",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/KeysRefreshPartner",
            "coinbase.crypto.core_kms.v1.operations_service.Crypto/FinalizeKeysRefresh",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingRegisterRootContainer",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingRegisterInstanceContainer",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingRegisterRootContainerAndInstance",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingContainerObjectsContentMarkerGet",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingContainerObjectsInfoGet",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingContainerObjectsInfoSet",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingContainerBackupRestore",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingContainerObjectsBackupBundleGetByChunk",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingContainerObjectsBackupCreate",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingGenericQuorumExport",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/FinalizeRoamingContainerObjectsBackupCreate",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/FinalizeRoamingContainerBackupRestore",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/FinalizeGenericQuorumBackupCreate",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/FinalizeGenericQuorumBackupRestore",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/GenericQuorumBackupCreate",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/GenericQuorumBackupRestore",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/RoamingHDMPCKeySetGetPublicKeysWithAttestation",
            "coinbase.crypto.core_kms.v1.operations_service.Roaming/FinalizeRoamingHDMPCKeySetGetPublicKeysWithAttestation"
        ].map(grpcMethod => `POST ${envPrefix}/mpc-eco/operations/${grpcMethod}`)
    };
}
const nowInSeconds = () => {
    return Math.floor(Date.now() / 1000);
};
async function buildJWT(apiKeyName, apiPrivateKey, service, uris) {
    const pemPrivateKey = extractPemKey(apiPrivateKey);
    let privateKey;
    try {
        privateKey = await JWK.asKey(pemPrivateKey, "pem");
        if (privateKey.kty !== "EC") {
            throw new Error("Not an EC private key");
        }
    }
    catch (error) {
        throw new Error(`jwt: Could not decode or parse private key. ${error}`);
    }
    const header = {
        alg: "ES256",
        kid: apiKeyName,
        typ: "JWT",
        nonce: nonce()
    };
    const now = nowInSeconds();
    const exp = now + 120;
    const claims = {
        sub: apiKeyName,
        iss: "coinbase-cloud",
        nbf: now,
        exp,
        aud: [service],
        uris: uris
    };
    const payload = Buffer.from(JSON.stringify(claims)).toString("utf8");
    try {
        const result = await JWS.createSign({ format: "compact", fields: header }, privateKey)
            .update(payload)
            .final();
        return result;
    }
    catch (err) {
        throw new Error(`jwt: Failed to sign JWT. ${err}`);
    }
}
function extractPemKey(privateKeyString) {
    privateKeyString = privateKeyString.replace(/\n/g, "");
    if (privateKeyString.startsWith(pemHeader) &&
        privateKeyString.endsWith(pemFooter)) {
        return privateKeyString;
    }
    const regex = new RegExp(`^${legacyPemHeader}([\\s\\S]+?)${legacyPemFooter}$`);
    const match = privateKeyString.match(regex);
    if (match && match[1]) {
        return pemHeader + match[1].trim() + pemFooter;
    }
    throw new Error("wrong format of API private key");
}
function nonce() {
    const range = "0123456789";
    let result = "";
    for (let i = 0; i < 16; i++) {
        result += range.charAt(Math.floor(Math.random() * range.length));
    }
    return result;
}
export async function issueAuthToken(options) {
    const uris = urisForEnv(WAAS_ENV_VALUE, options.prod === true);
    const [cws, ops] = await Promise.all([
        buildJWT(options.apiKeyName, options.privateKey, AUDIENCES["cws"], uris["cws"]),
        buildJWT(options.apiKeyName, options.privateKey, AUDIENCES["ops"], uris["ops"])
    ]);
    const waasAuth = {
        cws,
        ops
    };
    return btoa(JSON.stringify(waasAuth));
}
export async function issueUserToken(options) {
    const uri = "https://" + BASE_CLOUD_URLS[WAAS_ENV_VALUE];
    const cloudAccessToken = await issueCloudAccessAuthToken(options, BASE_CLOUD_URLS[WAAS_ENV_VALUE]);
    const { userID, ttlSeconds: ttl = MAX_TTL_SECONDS } = options;
    if (!isValidUUID(userID)) {
        throw new Error("Invalid user ID: Must be valid UUID.");
    }
    if (ttl > MAX_TTL_SECONDS || ttl <= 0) {
        throw new Error(`Invalid TTL: Must be be a positive integer less than ${MAX_TTL_SECONDS} seconds.`);
    }
    const response = await fetch(`${uri}/oauth/token`, {
        method: "POST",
        headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            Authorization: `Bearer ${cloudAccessToken}`
        },
        body: JSON.stringify({
            scopes: [
                `user:${userID}#waas_consumer_read`,
                `user:${userID}#waas_consumer_write`
            ],
            ttl,
            enable_refresh: true
        })
    });
    const json = await response.json();
    const waasAuth = {
        authToken: json.accessToken,
        refreshToken: json.refreshToken,
        endUserId: userID,
        cws: json.accessToken,
        ops: json.accessToken
    };
    return btoa(JSON.stringify(waasAuth));
}
async function issueCloudAccessAuthToken(options, baseUri) {
    const jwt = await buildJWT(options.apiKeyName, options.privateKey, "cloud_token_service", [`POST ${baseUri}/oauth/token`, `POST ${baseUri}/oauth/refresh`]);
    return jwt;
}
