"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunkA324YZTZcjs = require('./chunk-A324YZTZ.cjs');



var _chunk4OMBN3XJcjs = require('./chunk-4OMBN3XJ.cjs');

// src/auth/AccessToken.ts
var _jose = require('jose'); var jose = _interopRequireWildcard(_jose);
var _zod = require('zod');
var logger = _chunkA324YZTZcjs.mainLogger.createSubLogger("AccessToken");
var estimateSize = (obj) => {
  const str = JSON.stringify(obj);
  return new TextEncoder().encode(str).length;
};
function isDefaultRole(role) {
  return Object.values(Role).includes(role);
}
var RoleSchema = _zod.z.union([
  _zod.z.literal("host"),
  _zod.z.literal("coHost"),
  _zod.z.literal("speaker"),
  _zod.z.literal("listener"),
  _zod.z.literal("guest"),
  _zod.z.literal("bot")
]);
var Role = {
  HOST: "host",
  CO_HOST: "coHost",
  SPEAKER: "speaker",
  LISTENER: "listener",
  GUEST: "guest",
  BOT: "bot"
};
var Permissions = _zod.z.object({
  admin: _zod.z.boolean(),
  canConsume: _zod.z.boolean(),
  canProduce: _zod.z.boolean(),
  canProduceSources: _zod.z.object({
    cam: _zod.z.boolean(),
    mic: _zod.z.boolean(),
    screen: _zod.z.boolean()
  }),
  canSendData: _zod.z.boolean(),
  canRecvData: _zod.z.boolean(),
  canUpdateMetadata: _zod.z.boolean()
});
var DEFAULT_PERMISSIONS = {
  admin: false,
  canConsume: true,
  canProduce: true,
  canProduceSources: {
    cam: true,
    mic: true,
    screen: true
  },
  canRecvData: true,
  canSendData: true,
  canUpdateMetadata: true
};
var ROLE_PERMISSIONS = {
  [Role.HOST]: {
    ...DEFAULT_PERMISSIONS,
    admin: true
  },
  [Role.CO_HOST]: {
    ...DEFAULT_PERMISSIONS,
    admin: true
    /* ... other permissions for the co-host ... */
  },
  [Role.LISTENER]: {
    admin: false,
    canConsume: true,
    canProduce: false,
    canProduceSources: {
      cam: false,
      mic: false,
      screen: false
    },
    canRecvData: true,
    canSendData: true,
    canUpdateMetadata: true
  },
  [Role.SPEAKER]: {
    admin: false,
    canConsume: true,
    canProduce: true,
    canProduceSources: {
      cam: false,
      mic: true,
      screen: true
    },
    canRecvData: true,
    canSendData: true,
    canUpdateMetadata: true
  },
  [Role.BOT]: {
    admin: false,
    canConsume: true,
    canProduce: false,
    canProduceSources: {
      cam: false,
      mic: false,
      screen: false
    },
    canRecvData: false,
    canSendData: false,
    canUpdateMetadata: false
  },
  [Role.GUEST]: {
    ...DEFAULT_PERMISSIONS
  }
};
var AccessToken = (_class = class {
  
  
  
  /**
   * Permissions for the token
   */
  
  /**
   * Time to live for the token or expiration time. can be a number of seconds or a string describing a time span zeit/ms
   * @example  6 * 60 * 60, "2 days", "10h", "7d"`
   * @default 4h
   */
  __init() {this.ttl = "4h"}
  /**
   * custom app data for the peer
   */
  
  constructor(data) {;_class.prototype.__init.call(this);
    if (typeof document !== "undefined") {
      logger.error(
        "You should not include your API secret in your web client bundle.\n\nYour web client should request a token from your backend server which should then use "
      );
    }
    if (!data.apiKey) {
      throw new Error("api-key required");
    }
    if (!data.roomId) {
      throw new Error("roomId required");
    }
    if (_optionalChain([data, 'access', _ => _.options, 'optionalAccess', _2 => _2.metadata]) && estimateSize(_optionalChain([data, 'access', _3 => _3.options, 'optionalAccess', _4 => _4.metadata])) > _chunk4OMBN3XJcjs.MAX_METADATA_SIZE) {
      throw new Error("Metadata size exceeds the limit of 5kb");
    }
    this.apiKey = data.apiKey;
    this.roomId = data.roomId;
    this.metadata = _optionalChain([data, 'access', _5 => _5.options, 'optionalAccess', _6 => _6.metadata]);
    if (_optionalChain([data, 'access', _7 => _7.options, 'optionalAccess', _8 => _8.ttl]))
      this.ttl = _optionalChain([data, 'access', _9 => _9.options, 'optionalAccess', _10 => _10.ttl]);
    if ("role" in data) {
      if (isDefaultRole(data.role) && !("permissions" in data)) {
        this.role = data.role;
        this.permissions = ROLE_PERMISSIONS[data.role];
      } else if (isDefaultRole(data.role) && "permissions" in data) {
        this.role = data.role;
        this.permissions = {
          ...ROLE_PERMISSIONS[data.role],
          ...data.permissions
        };
      } else if (typeof data.role === "string" && "permissions" in data) {
        if (data.role.length > 20) {
          throw new Error(`Custom role exceeds the limit of ${20} characters.`);
        }
        this.role = data.role;
        this.permissions = {
          ...DEFAULT_PERMISSIONS,
          ...data.permissions
        };
      } else {
        throw new Error(
          `Permissions must be provided for custom role: ${data.role}.`
        );
      }
    } else if ("permissions" in data) {
      this.permissions = {
        ...DEFAULT_PERMISSIONS,
        ...data.permissions
      };
    } else {
      throw new Error("Either a role or permissions must be provided.");
    }
  }
  set updatePermissions(permissions) {
    this.permissions = permissions;
  }
  set updateMetaData(data) {
    if (data && estimateSize(data) > _chunk4OMBN3XJcjs.MAX_METADATA_SIZE) {
      throw new Error("Metadata size exceeds the limit of 5kb");
    }
    this.metadata = data;
  }
  /**
   * Generate a JWT token
   * @returns JWT token
   * @example
   * ```typescript
   * const accessToken = new AccessToken({...})
   * accessToken.toJwt()
   * ```
   */
  async toJwt() {
    const payload = {
      roomId: this.roomId,
      permissions: this.permissions,
      role: this.role,
      projectId: this.apiKey,
      metadata: JSON.stringify(this.metadata)
    };
    const resp = await fetch(`${_chunk4OMBN3XJcjs.IRIKO_URL}/api/v1/create-peer-token`, {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "Cache-Control": "no-store, max-age=0",
        Pragma: "no-cache"
      }
    });
    if (resp.status === 401) {
      throw new Error("API key missing or invalid");
    } else if (resp.status === 404) {
      throw new Error("Room not found to be associated with the given API key");
    }
    const { token } = await resp.json();
    return token;
  }
}, _class);
var TokenVerifier = class {
  
  constructor() {
    this.JWKS = jose.createRemoteJWKSet(
      new URL("https://iriko.huddle01.media/jwks.json")
    );
  }
  /**
   * Verify a JWT token
   * @param token JWT token
   * @returns decoded token
   * @example
   * ```typescript
   * const verifier = new TokenVerifier()
   * verifier.verify(token)
   * ```
   * @throws {jose.errors.JWTExpired} if the token is expired
   * @throws {jose.errors.JWTClaimValidationFailed} if the token is invalid
   */
  async verify(token) {
    const { payload } = await jose.jwtVerify(token, this.JWKS);
    return payload;
  }
};










exports.isDefaultRole = isDefaultRole; exports.RoleSchema = RoleSchema; exports.Role = Role; exports.Permissions = Permissions; exports.DEFAULT_PERMISSIONS = DEFAULT_PERMISSIONS; exports.ROLE_PERMISSIONS = ROLE_PERMISSIONS; exports.AccessToken = AccessToken; exports.TokenVerifier = TokenVerifier;
