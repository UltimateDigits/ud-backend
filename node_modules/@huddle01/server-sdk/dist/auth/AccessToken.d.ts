import * as jose from 'jose';
import { z } from 'zod';

declare function isDefaultRole(role: string): role is Role;
declare const RoleSchema: z.ZodUnion<[z.ZodLiteral<"host">, z.ZodLiteral<"coHost">, z.ZodLiteral<"speaker">, z.ZodLiteral<"listener">, z.ZodLiteral<"guest">, z.ZodLiteral<"bot">]>;
declare const Role: {
    readonly HOST: "host";
    readonly CO_HOST: "coHost";
    readonly SPEAKER: "speaker";
    readonly LISTENER: "listener";
    readonly GUEST: "guest";
    readonly BOT: "bot";
};
type Role = (typeof Role)[keyof typeof Role];
declare const Permissions: z.ZodObject<{
    admin: z.ZodBoolean;
    canConsume: z.ZodBoolean;
    canProduce: z.ZodBoolean;
    canProduceSources: z.ZodObject<{
        cam: z.ZodBoolean;
        mic: z.ZodBoolean;
        screen: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    }, {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    }>;
    canSendData: z.ZodBoolean;
    canRecvData: z.ZodBoolean;
    canUpdateMetadata: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    admin: boolean;
    canConsume: boolean;
    canProduce: boolean;
    canProduceSources: {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    };
    canSendData: boolean;
    canRecvData: boolean;
    canUpdateMetadata: boolean;
}, {
    admin: boolean;
    canConsume: boolean;
    canProduce: boolean;
    canProduceSources: {
        cam: boolean;
        mic: boolean;
        screen: boolean;
    };
    canSendData: boolean;
    canRecvData: boolean;
    canUpdateMetadata: boolean;
}>;
type Permissions = z.infer<typeof Permissions>;
declare const DEFAULT_PERMISSIONS: Permissions;
declare const ROLE_PERMISSIONS: Record<Role, Permissions>;
declare const MeetingTokenInputSchema: z.ZodObject<{
    roomId: z.ZodString;
    muteOnEntry: z.ZodOptional<z.ZodBoolean>;
    videoOnEntry: z.ZodOptional<z.ZodBoolean>;
    roomType: z.ZodOptional<z.ZodEnum<["AUDIO", "VIDEO"]>>;
    role: z.ZodOptional<z.ZodString>;
    permissions: z.ZodObject<{
        admin: z.ZodBoolean;
        canConsume: z.ZodBoolean;
        canProduce: z.ZodBoolean;
        canProduceSources: z.ZodObject<{
            cam: z.ZodBoolean;
            mic: z.ZodBoolean;
            screen: z.ZodBoolean;
        }, "strip", z.ZodTypeAny, {
            cam: boolean;
            mic: boolean;
            screen: boolean;
        }, {
            cam: boolean;
            mic: boolean;
            screen: boolean;
        }>;
        canSendData: z.ZodBoolean;
        canRecvData: z.ZodBoolean;
        canUpdateMetadata: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        admin: boolean;
        canConsume: boolean;
        canProduce: boolean;
        canProduceSources: {
            cam: boolean;
            mic: boolean;
            screen: boolean;
        };
        canSendData: boolean;
        canRecvData: boolean;
        canUpdateMetadata: boolean;
    }, {
        admin: boolean;
        canConsume: boolean;
        canProduce: boolean;
        canProduceSources: {
            cam: boolean;
            mic: boolean;
            screen: boolean;
        };
        canSendData: boolean;
        canRecvData: boolean;
        canUpdateMetadata: boolean;
    }>;
    ttl: z.ZodOptional<z.ZodNumber>;
    metadata: z.ZodOptional<z.ZodString>;
    options: z.ZodOptional<z.ZodObject<{
        maxPeersAllowed: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        maxPeersAllowed?: number | undefined;
    }, {
        maxPeersAllowed?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    roomId: string;
    permissions: {
        admin: boolean;
        canConsume: boolean;
        canProduce: boolean;
        canProduceSources: {
            cam: boolean;
            mic: boolean;
            screen: boolean;
        };
        canSendData: boolean;
        canRecvData: boolean;
        canUpdateMetadata: boolean;
    };
    options?: {
        maxPeersAllowed?: number | undefined;
    } | undefined;
    muteOnEntry?: boolean | undefined;
    videoOnEntry?: boolean | undefined;
    roomType?: "AUDIO" | "VIDEO" | undefined;
    role?: string | undefined;
    ttl?: number | undefined;
    metadata?: string | undefined;
}, {
    roomId: string;
    permissions: {
        admin: boolean;
        canConsume: boolean;
        canProduce: boolean;
        canProduceSources: {
            cam: boolean;
            mic: boolean;
            screen: boolean;
        };
        canSendData: boolean;
        canRecvData: boolean;
        canUpdateMetadata: boolean;
    };
    options?: {
        maxPeersAllowed?: number | undefined;
    } | undefined;
    muteOnEntry?: boolean | undefined;
    videoOnEntry?: boolean | undefined;
    roomType?: "AUDIO" | "VIDEO" | undefined;
    role?: string | undefined;
    ttl?: number | undefined;
    metadata?: string | undefined;
}>;
type IMeetingTokenInput = z.infer<typeof MeetingTokenInputSchema>;
type AccessTokenOptions<T> = {
    ttl?: number | string;
    maxPeersAllowed?: number;
    metadata?: T;
};
type AccessTokenData<P> = {
    apiKey: string;
    roomId: string;
    role: Role;
    options?: AccessTokenOptions<P>;
} | {
    apiKey: string;
    roomId: string;
    role: string;
    permissions: Partial<Permissions>;
    options?: AccessTokenOptions<P>;
} | {
    apiKey: string;
    roomId: string;
    permissions: Partial<Permissions>;
    options?: AccessTokenOptions<P>;
};
/**
 *  Access token for a peer
 */
declare class AccessToken<P = unknown> {
    private readonly apiKey;
    private readonly roomId;
    role: string | undefined;
    /**
     * Permissions for the token
     */
    permissions: Permissions;
    /**
     * Token Options object
     *
     * - `ttl`: Time to live for the token or expiration time. can be a number of seconds or a string describing a time span zeit/ms
     *  @example  6 * 60 * 60, "2 days", "10h", "7d"`
     *  @default 4h
     *
     * - `maxPeersAllowed`:  Maximum number of peers allowed in the room (Optional)
     */
    options: {
        ttl: number | string;
        maxPeersAllowed?: number;
    };
    /**
     * custom app data for the peer
     */
    metadata?: P;
    constructor(data: AccessTokenData<P>);
    set updatePermissions(permissions: Permissions);
    set updateMetaData(data: P);
    /**
     * Generate a JWT token
     * @returns JWT token
     * @example
     * ```typescript
     * const accessToken = new AccessToken({...})
     * accessToken.toJwt()
     * ```
     */
    toJwt(): Promise<string>;
}
/**
 * Token verifier
 */
declare class TokenVerifier<Q> {
    JWKS: (protectedHeader?: jose.JWSHeaderParameters | undefined, token?: jose.FlattenedJWSInput | undefined) => Promise<jose.KeyLike>;
    constructor();
    /**
     * Verify a JWT token
     * @param token JWT token
     * @returns decoded token
     * @example
     * ```typescript
     * const verifier = new TokenVerifier()
     * verifier.verify(token)
     * ```
     * @throws {jose.errors.JWTExpired} if the token is expired
     * @throws {jose.errors.JWTClaimValidationFailed} if the token is invalid
     */
    verify(token: string): Promise<{
        peerId: string;
        roomId: string;
        projectId: string;
        role?: Role;
        permissions: Permissions;
        displayName?: string;
        metadata?: Q;
    }>;
}

export { AccessToken, type AccessTokenOptions, DEFAULT_PERMISSIONS, type IMeetingTokenInput, MeetingTokenInputSchema, Permissions, ROLE_PERMISSIONS, Role, RoleSchema, TokenVerifier, isDefaultRole };
