import {
  mainLogger
} from "./chunk-YD27QE5C.js";
import {
  IRIKO_URL,
  MAX_METADATA_SIZE
} from "./chunk-5NLWQTRE.js";

// src/auth/AccessToken.ts
import * as jose from "jose";
import { z } from "zod";
var logger = mainLogger.createSubLogger("AccessToken");
var estimateSize = (obj) => {
  const str = JSON.stringify(obj);
  return new TextEncoder().encode(str).length;
};
function isDefaultRole(role) {
  return Object.values(Role).includes(role);
}
var RoleSchema = z.union([
  z.literal("host"),
  z.literal("coHost"),
  z.literal("speaker"),
  z.literal("listener"),
  z.literal("guest"),
  z.literal("bot")
]);
var Role = {
  HOST: "host",
  CO_HOST: "coHost",
  SPEAKER: "speaker",
  LISTENER: "listener",
  GUEST: "guest",
  BOT: "bot"
};
var Permissions = z.object({
  admin: z.boolean(),
  canConsume: z.boolean(),
  canProduce: z.boolean(),
  canProduceSources: z.object({
    cam: z.boolean(),
    mic: z.boolean(),
    screen: z.boolean()
  }),
  canSendData: z.boolean(),
  canRecvData: z.boolean(),
  canUpdateMetadata: z.boolean()
});
var DEFAULT_PERMISSIONS = {
  admin: false,
  canConsume: true,
  canProduce: true,
  canProduceSources: {
    cam: true,
    mic: true,
    screen: true
  },
  canRecvData: true,
  canSendData: true,
  canUpdateMetadata: true
};
var ROLE_PERMISSIONS = {
  [Role.HOST]: {
    ...DEFAULT_PERMISSIONS,
    admin: true
  },
  [Role.CO_HOST]: {
    ...DEFAULT_PERMISSIONS,
    admin: true
    /* ... other permissions for the co-host ... */
  },
  [Role.LISTENER]: {
    admin: false,
    canConsume: true,
    canProduce: false,
    canProduceSources: {
      cam: false,
      mic: false,
      screen: false
    },
    canRecvData: true,
    canSendData: true,
    canUpdateMetadata: true
  },
  [Role.SPEAKER]: {
    admin: false,
    canConsume: true,
    canProduce: true,
    canProduceSources: {
      cam: false,
      mic: true,
      screen: true
    },
    canRecvData: true,
    canSendData: true,
    canUpdateMetadata: true
  },
  [Role.BOT]: {
    admin: false,
    canConsume: true,
    canProduce: false,
    canProduceSources: {
      cam: false,
      mic: false,
      screen: false
    },
    canRecvData: false,
    canSendData: false,
    canUpdateMetadata: false
  },
  [Role.GUEST]: {
    ...DEFAULT_PERMISSIONS
  }
};
var AccessToken = class {
  apiKey;
  roomId;
  role;
  /**
   * Permissions for the token
   */
  permissions;
  /**
   * Time to live for the token or expiration time. can be a number of seconds or a string describing a time span zeit/ms
   * @example  6 * 60 * 60, "2 days", "10h", "7d"`
   * @default 4h
   */
  ttl = "4h";
  /**
   * custom app data for the peer
   */
  metadata;
  constructor(data) {
    if (typeof document !== "undefined") {
      logger.error(
        "You should not include your API secret in your web client bundle.\n\nYour web client should request a token from your backend server which should then use "
      );
    }
    if (!data.apiKey) {
      throw new Error("api-key required");
    }
    if (!data.roomId) {
      throw new Error("roomId required");
    }
    if (data.options?.metadata && estimateSize(data.options?.metadata) > MAX_METADATA_SIZE) {
      throw new Error("Metadata size exceeds the limit of 5kb");
    }
    this.apiKey = data.apiKey;
    this.roomId = data.roomId;
    this.metadata = data.options?.metadata;
    if (data.options?.ttl)
      this.ttl = data.options?.ttl;
    if ("role" in data) {
      if (isDefaultRole(data.role) && !("permissions" in data)) {
        this.role = data.role;
        this.permissions = ROLE_PERMISSIONS[data.role];
      } else if (isDefaultRole(data.role) && "permissions" in data) {
        this.role = data.role;
        this.permissions = {
          ...ROLE_PERMISSIONS[data.role],
          ...data.permissions
        };
      } else if (typeof data.role === "string" && "permissions" in data) {
        if (data.role.length > 20) {
          throw new Error(`Custom role exceeds the limit of ${20} characters.`);
        }
        this.role = data.role;
        this.permissions = {
          ...DEFAULT_PERMISSIONS,
          ...data.permissions
        };
      } else {
        throw new Error(
          `Permissions must be provided for custom role: ${data.role}.`
        );
      }
    } else if ("permissions" in data) {
      this.permissions = {
        ...DEFAULT_PERMISSIONS,
        ...data.permissions
      };
    } else {
      throw new Error("Either a role or permissions must be provided.");
    }
  }
  set updatePermissions(permissions) {
    this.permissions = permissions;
  }
  set updateMetaData(data) {
    if (data && estimateSize(data) > MAX_METADATA_SIZE) {
      throw new Error("Metadata size exceeds the limit of 5kb");
    }
    this.metadata = data;
  }
  /**
   * Generate a JWT token
   * @returns JWT token
   * @example
   * ```typescript
   * const accessToken = new AccessToken({...})
   * accessToken.toJwt()
   * ```
   */
  async toJwt() {
    const payload = {
      roomId: this.roomId,
      permissions: this.permissions,
      role: this.role,
      projectId: this.apiKey,
      metadata: JSON.stringify(this.metadata)
    };
    const resp = await fetch(`${IRIKO_URL}/api/v1/create-peer-token`, {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "Cache-Control": "no-store, max-age=0",
        Pragma: "no-cache"
      }
    });
    if (resp.status === 401) {
      throw new Error("API key missing or invalid");
    } else if (resp.status === 404) {
      throw new Error("Room not found to be associated with the given API key");
    }
    const { token } = await resp.json();
    return token;
  }
};
var TokenVerifier = class {
  JWKS;
  constructor() {
    this.JWKS = jose.createRemoteJWKSet(
      new URL("https://iriko.huddle01.media/jwks.json")
    );
  }
  /**
   * Verify a JWT token
   * @param token JWT token
   * @returns decoded token
   * @example
   * ```typescript
   * const verifier = new TokenVerifier()
   * verifier.verify(token)
   * ```
   * @throws {jose.errors.JWTExpired} if the token is expired
   * @throws {jose.errors.JWTClaimValidationFailed} if the token is invalid
   */
  async verify(token) {
    const { payload } = await jose.jwtVerify(token, this.JWKS);
    return payload;
  }
};

export {
  isDefaultRole,
  RoleSchema,
  Role,
  Permissions,
  DEFAULT_PERMISSIONS,
  ROLE_PERMISSIONS,
  AccessToken,
  TokenVerifier
};
