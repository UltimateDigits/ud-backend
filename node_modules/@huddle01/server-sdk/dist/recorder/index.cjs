"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunkA324YZTZcjs = require('../chunk-A324YZTZ.cjs');


var _chunk4OMBN3XJcjs = require('../chunk-4OMBN3XJ.cjs');
require('../chunk-AITBUDWZ.cjs');

// ../types/dist/validators/common.validators.js
var _zod = require('zod');
var ActivePeersSchema = _zod.z.object({
  peerIds: _zod.z.array(_zod.z.string()),
  dominantSpeaker: _zod.z.string()
});
var RoomControlsSchema = _zod.z.object({
  roomLocked: _zod.z.boolean(),
  allowProduce: _zod.z.boolean(),
  allowProduceSources: _zod.z.object({
    cam: _zod.z.boolean().default(true),
    mic: _zod.z.boolean().default(true),
    screen: _zod.z.boolean().default(true)
  }),
  allowConsume: _zod.z.boolean(),
  allowSendData: _zod.z.boolean()
});
var produceSourcesSchema = _zod.z.object({
  cam: _zod.z.boolean(),
  mic: _zod.z.boolean(),
  screen: _zod.z.boolean()
});
var PermissionSchema = _zod.z.object({
  admin: _zod.z.boolean(),
  canConsume: _zod.z.boolean(),
  canProduce: _zod.z.boolean(),
  canProduceSources: produceSourcesSchema,
  canSendData: _zod.z.boolean(),
  canRecvData: _zod.z.boolean(),
  canUpdateMetadata: _zod.z.boolean()
});
var VolatileDataMessageSchema = _zod.z.object({
  from: _zod.z.string(),
  payload: _zod.z.unknown(),
  label: _zod.z.string().optional(),
  to: _zod.z.union([_zod.z.literal("*"), _zod.z.array(_zod.z.string())]).optional()
});
var RecordingTypeSchema = _zod.z.enum(["recording", "livestream"]);
var ApiKeyRecordingStatusSchema = _zod.z.object({
  status: _zod.z.enum(["ongoing", "stopped"]),
  startTime: _zod.z.number().optional(),
  type: RecordingTypeSchema.optional()
});

// src/recorder/index.ts
var logger = _chunkA324YZTZcjs.mainLogger.createSubLogger("Recorder");
var Recorder = (_class = class {
  
  
  __init() {this.url = "https://apira.huddle01.media/api/v1"}
  constructor(projectId, apiKey) {;_class.prototype.__init.call(this);
    logger.info("\u{1F514} Initializing Recorder SDK");
    this.projectId = projectId;
    this.apiKey = apiKey;
  }
  async startRecording(data) {
    if (_optionalChain([data, 'access', _ => _.options, 'optionalAccess', _2 => _2.audioOnly]) && _optionalChain([data, 'access', _3 => _3.options, 'optionalAccess', _4 => _4.videoOnly]))
      throw new Error(
        "Cannot record with both audioOnly and videoOnly options"
      );
    const res = await fetch(`${this.url}/recording/start`, {
      body: JSON.stringify({
        roomId: data.roomId,
        token: data.token,
        layout: data.layout || "grid",
        projectId: this.projectId,
        customLayoutUrl: data.customLayoutUrl,
        customStorage: data.customStorage,
        watermark: data.watermark,
        pinToIpfs: data.pinToIpfs,
        options: data.options,
        type: RecordingTypeSchema.Enum.recording
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      }
    });
    const d = await res.json();
    return d;
  }
  async startLivestream(data) {
    const res = await fetch(`${this.url}/recording/start`, {
      body: JSON.stringify({
        roomId: data.roomId,
        token: data.token,
        layout: "grid",
        projectId: this.projectId,
        rtmpUrls: data.rtmpUrls,
        customLayoutUrl: data.customLayoutUrl,
        customStorage: data.customStorage,
        type: RecordingTypeSchema.Enum.livestream,
        recordLivestream: data.recordLivestream
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      }
    });
    const d = await res.json();
    return d;
  }
  async stop(data) {
    const res = await fetch(`${this.url}/recording/stop`, {
      body: JSON.stringify({
        roomId: data.roomId
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      }
    });
    const d = await res.json();
    return d;
  }
  async getRecordingStatus(data) {
    const res = await fetch(`${this.url}/recording/status`, {
      body: JSON.stringify({
        roomId: data.roomId
      }),
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      }
    });
    const d = await res.json();
    return d;
  }
  async getRecordings(data) {
    try {
      const resp = await fetch(`${_chunk4OMBN3XJcjs.IRIKO_URL}/api/v1/get-recordings`, {
        method: "GET",
        body: data ? JSON.stringify(data) : void 0,
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.apiKey
        }
      });
      if (resp.status === 401) {
        throw new Error("\u274C API key missing or invalid");
      }
      const res = await resp.json();
      return { data: res };
    } catch (error) {
      logger.error("\u274C Error in fetching recordings");
      logger.error(error);
      return {
        data: null,
        error: new Error("\u274C Error in fetching recordings")
      };
    }
  }
}, _class);


exports.Recorder = Recorder;
