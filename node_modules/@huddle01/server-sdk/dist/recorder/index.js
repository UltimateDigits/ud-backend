import {
  mainLogger
} from "../chunk-YD27QE5C.js";
import {
  IRIKO_URL
} from "../chunk-5NLWQTRE.js";
import "../chunk-VBXJIVYU.js";

// ../types/dist/validators/common.validators.js
import { z } from "zod";
var ActivePeersSchema = z.object({
  peerIds: z.array(z.string()),
  dominantSpeaker: z.string()
});
var RoomControlsSchema = z.object({
  roomLocked: z.boolean(),
  allowProduce: z.boolean(),
  allowProduceSources: z.object({
    cam: z.boolean().default(true),
    mic: z.boolean().default(true),
    screen: z.boolean().default(true)
  }),
  allowConsume: z.boolean(),
  allowSendData: z.boolean()
});
var produceSourcesSchema = z.object({
  cam: z.boolean(),
  mic: z.boolean(),
  screen: z.boolean()
});
var PermissionSchema = z.object({
  admin: z.boolean(),
  canConsume: z.boolean(),
  canProduce: z.boolean(),
  canProduceSources: produceSourcesSchema,
  canSendData: z.boolean(),
  canRecvData: z.boolean(),
  canUpdateMetadata: z.boolean()
});
var VolatileDataMessageSchema = z.object({
  from: z.string(),
  payload: z.unknown(),
  label: z.string().optional(),
  to: z.union([z.literal("*"), z.array(z.string())]).optional()
});
var RecordingTypeSchema = z.enum(["recording", "livestream"]);
var ApiKeyRecordingStatusSchema = z.object({
  status: z.enum(["ongoing", "stopped"]),
  startTime: z.number().optional(),
  type: RecordingTypeSchema.optional()
});

// src/recorder/index.ts
var logger = mainLogger.createSubLogger("Recorder");
var Recorder = class {
  projectId;
  apiKey;
  url = "https://apira.huddle01.media/api/v1";
  constructor(projectId, apiKey) {
    logger.info("\u{1F514} Initializing Recorder SDK");
    this.projectId = projectId;
    this.apiKey = apiKey;
  }
  async startRecording(data) {
    if (data.options?.audioOnly && data.options?.videoOnly)
      throw new Error(
        "Cannot record with both audioOnly and videoOnly options"
      );
    const res = await fetch(`${this.url}/recording/start`, {
      body: JSON.stringify({
        roomId: data.roomId,
        token: data.token,
        layout: data.layout || "grid",
        projectId: this.projectId,
        customLayoutUrl: data.customLayoutUrl,
        customStorage: data.customStorage,
        watermark: data.watermark,
        pinToIpfs: data.pinToIpfs,
        options: data.options,
        type: RecordingTypeSchema.Enum.recording
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      }
    });
    const d = await res.json();
    return d;
  }
  async startLivestream(data) {
    const res = await fetch(`${this.url}/recording/start`, {
      body: JSON.stringify({
        roomId: data.roomId,
        token: data.token,
        layout: "grid",
        projectId: this.projectId,
        rtmpUrls: data.rtmpUrls,
        customLayoutUrl: data.customLayoutUrl,
        customStorage: data.customStorage,
        type: RecordingTypeSchema.Enum.livestream,
        recordLivestream: data.recordLivestream
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      }
    });
    const d = await res.json();
    return d;
  }
  async stop(data) {
    const res = await fetch(`${this.url}/recording/stop`, {
      body: JSON.stringify({
        roomId: data.roomId
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      }
    });
    const d = await res.json();
    return d;
  }
  async getRecordingStatus(data) {
    const res = await fetch(`${this.url}/recording/status`, {
      body: JSON.stringify({
        roomId: data.roomId
      }),
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      }
    });
    const d = await res.json();
    return d;
  }
  async getRecordings(data) {
    try {
      const resp = await fetch(`${IRIKO_URL}/api/v1/get-recordings`, {
        method: "GET",
        body: data ? JSON.stringify(data) : void 0,
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.apiKey
        }
      });
      if (resp.status === 401) {
        throw new Error("\u274C API key missing or invalid");
      }
      const res = await resp.json();
      return { data: res };
    } catch (error) {
      logger.error("\u274C Error in fetching recordings");
      logger.error(error);
      return {
        data: null,
        error: new Error("\u274C Error in fetching recordings")
      };
    }
  }
};
export {
  Recorder
};
